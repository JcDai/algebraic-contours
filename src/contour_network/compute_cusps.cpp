// Copyright 2023 Adobe Research. All rights reserved.
// To view a copy of the license, visit LICENSE.md.

#include "compute_cusps.h"

#include "compute_curve_frame.h"
#include "compute_ray_intersections_pencil_method.h"

void
compute_quadratic_surface_cusp_function(
  const Matrix6x3r& surface_mapping_coeffs,
  const Matrix6x3r& normal_mapping_coeffs,
  const Matrix3x3r& frame,
  const Conic& contour_domain_curve_segment,
  RationalFunction<12, 1>& cusp_function)
{
  // Compute the contour tangent normal function
  RationalFunction<8, 3> contour_segment_tangent;
  RationalFunction<4, 3> contour_segment_normal;
  RationalFunction<12, 3> contour_segment_tangent_normal;
  compute_quadratic_surface_curve_frame(surface_mapping_coeffs,
                                        normal_mapping_coeffs,
                                        contour_domain_curve_segment,
                                        contour_segment_tangent,
                                        contour_segment_normal,
                                        contour_segment_tangent_normal);

  // Compute the component of the tangent normal in the camera direction
  Eigen::Matrix<double, 3, 1> tau = frame.col(2);
  contour_segment_tangent_normal.apply_one_form(tau, cusp_function);
}

// Compute the cusp function for a single patch
void
compute_spline_surface_patch_cusp_function(
  const QuadraticSplineSurfacePatch spline_surface_patch,
  const Matrix3x3r& frame,
  const Conic& contour_domain_curve_segment,
  RationalFunction<12, 1>& cusp_function)
{
  // Generate surface and normal mappings
  Matrix6x3r surface_mapping_coeffs =
    spline_surface_patch.get_surface_mapping();
  Matrix6x3r normal_mapping_coeffs = spline_surface_patch.get_normal_mapping();

  // Compute cusp function for quadratic surface patch
  compute_quadratic_surface_cusp_function(surface_mapping_coeffs,
                                          normal_mapping_coeffs,
                                          frame,
                                          contour_domain_curve_segment,
                                          cusp_function);
}

void
compute_spline_surface_cusp_functions(
  const QuadraticSplineSurface& spline_surface,
  const Matrix3x3r& frame,
  const std::vector<Conic>& contour_domain_curve_segments,
  const std::vector<QuadraticSplineSurface::PatchIndex>& patch_indices,
  std::vector<RationalFunction<12, 1>>& cusp_functions)
{
  cusp_functions.resize(contour_domain_curve_segments.size());
  for (size_t i = 0; i < contour_domain_curve_segments.size(); ++i) {
    QuadraticSplineSurface::PatchIndex patch_index = patch_indices[i];
    compute_spline_surface_patch_cusp_function(
      spline_surface.get_patch(patch_index),
      frame,
      contour_domain_curve_segments[i],
      cusp_functions[i]);
  }
}

// FIXME Autogenerated black box code
void
tangentx(double px[6], double py[6], double tx[6])
{
  double t10;
  double t11;
  double t13;
  double t14;
  double t17;
  double t20;
  double t24;
  double t27;
  double t3;
  double t35;
  double t4;
  double t41;
  double t48;
  double t52;
  double t7;
  double t8;
  t3 = px[1];
  t4 = py[5];
  t7 = px[2];
  t8 = py[3];
  t10 = px[3];
  t11 = py[2];
  t13 = px[5];
  t14 = py[1];
  t17 = -t11 * t10 + 0.2e1 * t14 * t13 - 0.2e1 * t3 * t4 + t7 * t8;
  t20 = py[4];
  t24 = px[4];
  t27 = -t14 * t10 + 0.2e1 * t11 * t24 - 0.2e1 * t20 * t7 + t3 * t8;
  t35 = 0.4e1 * t13 * t20 - 0.4e1 * t24 * t4;
  t41 = -0.4e1 * t10 * t20 + 0.4e1 * t24 * t8;
  t48 = -0.4e1 * t10 * t4 + 0.4e1 * t13 * t8;
  t52 = -t35;
  tx[0] = t17 * t3 + t27 * t7;
  tx[1] = t10 * t27 + 0.2e1 * t17 * t24 + t3 * t35 + t41 * t7;
  tx[2] = t10 * t17 + 0.2e1 * t13 * t27 + t3 * t48 + t52 * t7;
  tx[3] = t10 * t35 + t10 * t52 + 0.2e1 * t13 * t41 + 0.2e1 * t24 * t48;
  tx[4] = t10 * t41 + 0.2e1 * t24 * t35;
  tx[5] = t10 * t48 + 0.2e1 * t13 * t52;
}
void
tangenty(double px[6], double py[6], double ty[6])
{
  double t10;
  double t11;
  double t13;
  double t14;
  double t17;
  double t20;
  double t24;
  double t27;
  double t3;
  double t35;
  double t4;
  double t41;
  double t48;
  double t52;
  double t7;
  double t8;
  t3 = px[1];
  t4 = py[5];
  t7 = px[2];
  t8 = py[3];
  t10 = px[3];
  t11 = py[2];
  t13 = px[5];
  t14 = py[1];
  t17 = -t11 * t10 + 0.2e1 * t14 * t13 - 0.2e1 * t3 * t4 + t7 * t8;
  t20 = py[4];
  t24 = px[4];
  t27 = -t14 * t10 + 0.2e1 * t11 * t24 - 0.2e1 * t20 * t7 + t3 * t8;
  t35 = 0.4e1 * t13 * t20 - 0.4e1 * t24 * t4;
  t41 = -0.4e1 * t10 * t20 + 0.4e1 * t24 * t8;
  t48 = -0.4e1 * t10 * t4 + 0.4e1 * t13 * t8;
  t52 = -t35;
  ty[0] = t11 * t27 + t14 * t17;
  ty[1] = t11 * t41 + t14 * t35 + 0.2e1 * t17 * t20 + t27 * t8;
  ty[2] = t11 * t52 + t14 * t48 + t17 * t8 + 0.2e1 * t27 * t4;
  ty[3] = 0.2e1 * t20 * t48 + t35 * t8 + 0.2e1 * t4 * t41 + t52 * t8;
  ty[4] = 0.2e1 * t20 * t35 + t41 * t8;
  ty[5] = 0.2e1 * t4 * t52 + t48 * t8;
}

void
tangentz(double px[6], double py[6], double pz[6], double tz[6])
{
  double t11;
  double t12;
  double t14;
  double t15;
  double t18;
  double t19;
  double t22;
  double t26;
  double t29;
  double t30;
  double t33;
  double t39;
  double t4;
  double t41;
  double t46;
  double t5;
  double t53;
  double t55;
  double t58;
  double t8;
  double t9;
  t4 = px[1];
  t5 = py[5];
  t8 = py[3];
  t9 = px[2];
  t11 = px[3];
  t12 = py[2];
  t14 = px[5];
  t15 = py[1];
  t18 = -t12 * t11 + 0.2e1 * t15 * t14 - 0.2e1 * t4 * t5 + t8 * t9;
  t19 = pz[1];
  t22 = py[4];
  t26 = px[4];
  t29 = -t15 * t11 + 0.2e1 * t12 * t26 - 0.2e1 * t22 * t9 + t4 * t8;
  t30 = pz[2];
  t33 = pz[4];
  t39 = 0.4e1 * t14 * t22 - 0.4e1 * t26 * t5;
  t41 = pz[3];
  t46 = -0.4e1 * t11 * t22 + 0.4e1 * t26 * t8;
  t53 = -0.4e1 * t11 * t5 + 0.4e1 * t14 * t8;
  t55 = pz[5];
  t58 = -t39;
  tz[0] = t18 * t19 + t29 * t30;
  tz[1] = 0.2e1 * t33 * t18 + t19 * t39 + t29 * t41 + t30 * t46;
  tz[2] = t18 * t41 + t19 * t53 + 0.2e1 * t29 * t55 + t30 * t58;
  tz[3] = 0.2e1 * t33 * t53 + t39 * t41 + t41 * t58 + 0.2e1 * t46 * t55;
  tz[4] = 0.2e1 * t33 * t39 + t41 * t46;
  tz[5] = t41 * t53 + 0.2e1 * t55 * t58;
}

void
normalx(double py[6], double pz[6], double nx[6])
{
  double t10;
  double t12;
  double t15;
  double t17;
  double t21;
  double t26;
  double t3;
  double t4;
  double t6;
  double t7;
  t3 = py[1];
  t4 = pz[2];
  t6 = pz[1];
  t7 = py[2];
  t10 = pz[3];
  t12 = pz[4];
  t15 = py[3];
  t17 = py[4];
  t21 = pz[5];
  t26 = py[5];
  nx[0] = t3 * t4 - t6 * t7;
  nx[1] = t10 * t3 - 0.2e1 * t12 * t7 - t15 * t6 + 0.2e1 * t17 * t4;
  nx[2] = -t10 * t7 + t15 * t4 + 0.2e1 * t21 * t3 - 0.2e1 * t26 * t6;
  nx[3] = -0.4e1 * t12 * t26 + 0.4e1 * t17 * t21;
  nx[4] = 0.2e1 * t17 * t10 - 0.2e1 * t15 * t12;
  nx[5] = -0.2e1 * t10 * t26 + 0.2e1 * t15 * t21;
}
void
normaly(double px[6], double pz[6], double ny[6])
{
  double t10;
  double t12;
  double t15;
  double t17;
  double t21;
  double t26;
  double t3;
  double t4;
  double t6;
  double t7;
  t3 = px[1];
  t4 = pz[2];
  t6 = pz[1];
  t7 = px[2];
  t10 = pz[3];
  t12 = pz[4];
  t15 = px[3];
  t17 = px[4];
  t21 = pz[5];
  t26 = px[5];
  ny[0] = -t3 * t4 + t6 * t7;
  ny[1] = -t10 * t3 + 0.2e1 * t12 * t7 + t15 * t6 - 0.2e1 * t17 * t4;
  ny[2] = t10 * t7 - t15 * t4 - 0.2e1 * t21 * t3 + 0.2e1 * t26 * t6;
  ny[3] = 0.4e1 * t12 * t26 - 0.4e1 * t17 * t21;
  ny[4] = -0.2e1 * t17 * t10 + 0.2e1 * t15 * t12;
  ny[5] = 0.2e1 * t10 * t26 - 0.2e1 * t15 * t21;
}
void
normalz(double px[6], double py[6], double nz[6])
{
  double t10;
  double t12;
  double t15;
  double t17;
  double t21;
  double t26;
  double t3;
  double t4;
  double t6;
  double t7;
  t3 = px[1];
  t4 = py[2];
  t6 = py[1];
  t7 = px[2];
  t10 = py[3];
  t12 = py[4];
  t15 = px[3];
  t17 = px[4];
  t21 = py[5];
  t26 = px[5];
  nz[0] = t3 * t4 - t6 * t7;
  nz[1] = t10 * t3 - 0.2e1 * t12 * t7 - t15 * t6 + 0.2e1 * t17 * t4;
  nz[2] = -t10 * t7 + t15 * t4 + 0.2e1 * t21 * t3 - 0.2e1 * t26 * t6;
  nz[3] = -0.4e1 * t12 * t26 + 0.4e1 * t17 * t21;
  nz[4] = 0.2e1 * t17 * t10 - 0.2e1 * t15 * t12;
  nz[5] = -0.2e1 * t10 * t26 + 0.2e1 * t15 * t21;
}

double
evaluate(double p[6], double u, double v)
{
  return p[0] + p[1] * u + p[2] * v + p[3] * u * v + p[4] * u * u +
         p[5] * v * v;
}

bool
check_validity_by_equation(double p[6], double u, double v)
{
  if (float_equal_zero(evaluate(p, u, v)))
    return true;
  return false;
}

void
compute_cusp_by_one_patch(
  const QuadraticSplineSurfacePatch& spline_surface_patch,
  const Conic& contour_domain_curve_segment,
  std::vector<double>& conics)
{
  const Matrix6x3r normalized_surface_mapping_coeffs =
    spline_surface_patch.get_normalized_surface_mapping();
  double px[6], py[6], pz[6], tx[6], ty[6];
  for (int i = 0; i < 6; i++) {
    px[i] = normalized_surface_mapping_coeffs(i, 0);
    py[i] = normalized_surface_mapping_coeffs(i, 1);
    pz[i] = normalized_surface_mapping_coeffs(i, 2);
  }

  tangentx(px, py, tx);
  tangenty(px, py, ty);

  // normalized solution
  int num_solutions;
  std::array<PlanarPoint, 4> solutions;
  solve_quadratic_quadratic_equation_pencil_method(
    tx, ty, num_solutions, solutions);

  std::vector<PlanarPoint> solutions_in_domain;
  // check whether the solution is inside the domain
  for (int i = 0; i < num_solutions; i++) {
    double u = solutions[i][0];
    double v = solutions[i][1];
    // is it the case?
    if (u >= 0 && v >= 0 && u + v <= 1) {
      solutions_in_domain.push_back(
        spline_surface_patch.denormalize_domain_point(solutions[i]));
    }
  }

  if (solutions_in_domain.size() == 0)
    return;

  // get t on the conic
  const Matrix3x2r& conic_numerators =
    contour_domain_curve_segment.get_numerators();
  const Eigen::Matrix<double, 3, 1>& conic_denominators =
    contour_domain_curve_segment.get_denominator();
  const Eigen::Matrix<double, 3, 1> pu = conic_numerators.col(0);
  const Eigen::Matrix<double, 3, 1> pv = conic_numerators.col(1);
  const Eigen::Matrix<double, 3, 1> q = conic_denominators;

  bool linear_pu = float_equal_zero(pu[2]);
  bool linear_pv = float_equal_zero(pv[2]);

  for (size_t i = 0; i < solutions_in_domain.size(); i++) {
    double u = solutions_in_domain[i][0];
    double v = solutions_in_domain[i][1];
    if (!linear_pu && !linear_pv) {
      if (abs(pu[2]) > abs(pv[2])) {
        // solve pu(t) = u * q(t)
        std::vector<double> t_conic = polynomial_real_roots(pu - u * q);
        // check which t is correct
        for (size_t k = 0; k < t_conic.size(); k++) {
          double t = t_conic[k];

          if (float_equal(pv[0] + pv[1] * t + pv[2] * t * t,
                          (q[0] + q[1] * t + q[2] * t * t) * v,
                          1e-9)) {
            if (contour_domain_curve_segment.domain().contains(t)) {
              conics.push_back(t);
              break;
            }
          }
        }
      } else {
        // solve pv(t) = v * q(t)
        std::vector<double> t_conic = polynomial_real_roots(pv - v * q);
        // check which t is correct
        for (size_t k = 0; k < t_conic.size(); k++) {
          double t = t_conic[k];
          if (float_equal(pu[0] + pu[1] * t + pu[2] * t * t,
                          (q[0] + q[1] * t + q[2] * t * t) * u,
                          1e-9)) {
            if (contour_domain_curve_segment.domain().contains(t)) {
              conics.push_back(t);
              break;
            }
          }
        }
      }
    } else {
      if (!linear_pu) {
        std::vector<double> t_conic = polynomial_real_roots(pu - u * q);
        // check which t is correct
        for (size_t k = 0; k < t_conic.size(); k++) {
          double t = t_conic[k];
          if (float_equal(pv[0] + pv[1] * t + pv[2] * t * t,
                          (q[0] + q[1] * t + q[2] * t * t) * v,
                          1e-9)) {
            if (contour_domain_curve_segment.domain().contains(t)) {
              conics.push_back(t);
              break;
            }
          }
        }
      } else if (!linear_pv) {
        // solve pv(t) = v * q(t)
        std::vector<double> t_conic = polynomial_real_roots(pv - v * q);
        // check which t is correct
        for (size_t k = 0; k < t_conic.size(); k++) {
          double t = t_conic[k];
          if (float_equal(pu[0] + pu[1] * t + pu[2] * t * t,
                          (q[0] + q[1] * t + q[2] * t * t) * u,
                          1e-9)) {
            if (contour_domain_curve_segment.domain().contains(t)) {
              conics.push_back(t);
              break;
            }
          }
        }
      } else {
        if (abs(pu[1]) > abs(pu[2])) {
          std::vector<double> t_conic = polynomial_real_roots(pu - u * q);
          // check which t is correct
          for (size_t k = 0; k < t_conic.size(); k++) {
            double t = t_conic[k];
            if (float_equal(pv[0] + pv[1] * t + pv[2] * t * t,
                            (q[0] + q[1] * t + q[2] * t * t) * v,
                            1e-9)) {
              if (contour_domain_curve_segment.domain().contains(t)) {
                conics.push_back(t);
                break;
              }
            }
          }
        } else {
          std::vector<double> t_conic = polynomial_real_roots(pv - v * q);
          // check which t is correct
          for (size_t k = 0; k < t_conic.size(); k++) {
            double t = t_conic[k];
            if (float_equal(pu[0] + pu[1] * t + pu[2] * t * t,
                            (q[0] + q[1] * t + q[2] * t * t) * u,
                            1e-9)) {
              if (contour_domain_curve_segment.domain().contains(t)) {
                conics.push_back(t);
                break;
              }
            }
          }
        }
      }
    }
  }
}

void
compute_cusp_start_end_points(
  const QuadraticSplineSurface& spline_surface,
  const std::vector<Conic>& contour_domain_curve_segments,
  const std::vector<QuadraticSplineSurface::PatchIndex>& patch_indices,
  std::vector<double>& function_start_points,
  std::vector<double>& function_end_points,
  std::vector<double>& function_start_points_param,
  std::vector<double>& function_end_points_param)
{

  function_start_points.resize(contour_domain_curve_segments.size());
  function_end_points.resize(contour_domain_curve_segments.size());
  function_start_points_param.resize(contour_domain_curve_segments.size());
  function_end_points_param.resize(contour_domain_curve_segments.size());

  for (size_t i = 0; i < contour_domain_curve_segments.size(); i++) {
    const Conic& conic = contour_domain_curve_segments[i];
    const QuadraticSplineSurfacePatch& patch =
      spline_surface.get_patch(patch_indices[i]);
    const Matrix6x3r& surface_mapping = patch.get_surface_mapping();
    double t_start = conic.domain().get_lower_bound();
    double t_end = conic.domain().get_upper_bound();
    double px[6], py[6], pz[6], tx[6], ty[6], nx[6], ny[6];
    for (size_t i = 0; i < 6; i++) {
      px[i] = surface_mapping(i, 0);
      py[i] = surface_mapping(i, 1);
      pz[i] = surface_mapping(i, 2);
    }

    tangentx(px, py, tx);
    tangenty(px, py, ty);
    normalx(py, pz, nx);
    normaly(px, pz, ny);

    PlanarPoint uv_start, uv_end;
    conic.evaluate(t_start, uv_start);
    conic.evaluate(t_end, uv_end);

    double nx_start = evaluate(nx, uv_start[0], uv_start[1]);
    double ny_start = evaluate(ny, uv_start[0], uv_start[1]);
    double tx_start = evaluate(tx, uv_start[0], uv_start[1]);
    double ty_start = evaluate(ty, uv_start[0], uv_start[1]);
    double nx_end = evaluate(nx, uv_end[0], uv_end[1]);
    double ny_end = evaluate(ny, uv_end[0], uv_end[1]);
    double tx_end = evaluate(tx, uv_end[0], uv_end[1]);
    double ty_end = evaluate(ty, uv_end[0], uv_end[1]);

    double z_start = nx_start * ty_start - ny_start * tx_start;
    double z_end = nx_end * ty_end - ny_end * tx_end;

    function_start_points[i] = z_start;
    function_end_points[i] = z_end;
    function_start_points_param[i] = t_start;
    function_end_points_param[i] = t_end;
  }
}

void
compute_boundary_cusps(
  const std::vector<double>& cusp_function_start_points,
  const std::vector<double>& cusp_function_end_points,
  const std::vector<double>& cusp_function_start_points_param,
  const std::vector<double>& cusp_function_end_points_param,
  const std::vector<std::vector<int>>& closed_contours,
  std::vector<std::vector<double>>& boundary_cusps,
  std::vector<bool>& has_cusp_at_base,
  std::vector<bool>& has_cusp_at_tip)
{

  size_t num_segments = cusp_function_start_points.size();
  size_t num_closed_contours = closed_contours.size();
  boundary_cusps.clear();
  boundary_cusps.resize(num_segments);
  has_cusp_at_base.clear();
  has_cusp_at_base.resize(num_segments, false);
  has_cusp_at_tip.clear();
  has_cusp_at_tip.resize(num_segments, false);

  for (size_t i = 0; i < num_closed_contours; ++i) {
    for (size_t j = 0; j < closed_contours[i].size(); ++j) {
      // Get cusp function values around the boundary
      int current_segment = closed_contours[i][j];
      int next_segment =
        closed_contours[i][(j + 1) % closed_contours[i].size()];
      double cusp_function_limit_from_left =
        cusp_function_end_points[current_segment];
      double cusp_function_limit_from_right =
        cusp_function_start_points[next_segment];

      // Add cusps if there is a sign change
      if ((cusp_function_limit_from_left * cusp_function_limit_from_right) <
          0) {
        // Add cusp for current segments
        double current_segment_cusp =
          cusp_function_end_points_param[current_segment];
        boundary_cusps[current_segment].push_back(current_segment_cusp);

        // Add cusp for next segment
        double next_segment_cusp =
          cusp_function_start_points_param[next_segment];
        boundary_cusps[next_segment].push_back(next_segment_cusp);

        // Mark cusps
        has_cusp_at_base[next_segment] = true;
        has_cusp_at_tip[current_segment] = true;
      }
    }
  }
}

void
compute_spline_surface_cusps(
  const QuadraticSplineSurface& spline_surface,
  const std::vector<Conic>& contour_domain_curve_segments,
  const std::vector<RationalFunction<4, 3>>& contour_segments,
  const std::vector<QuadraticSplineSurface::PatchIndex>& patch_indices,
  const std::vector<std::vector<int>>& closed_contours,
  std::vector<std::vector<double>>& interior_cusps,
  std::vector<std::vector<double>>& boundary_cusps,
  std::vector<bool>& has_cusp_at_base,
  std::vector<bool>& has_cusp_at_tip)
{

  interior_cusps.resize(contour_segments.size());
  boundary_cusps.resize(contour_segments.size());

  // interior conics
  for (size_t i = 0; i < contour_domain_curve_segments.size(); i++) {

    compute_cusp_by_one_patch(spline_surface.get_patch(patch_indices[i]),
                              contour_domain_curve_segments[i],
                              interior_cusps[i]);
  }

  // compute cusp funtion endpoints
  std::vector<double> function_start_points;
  std::vector<double> function_end_points;
  std::vector<double> function_start_points_param;
  std::vector<double> function_end_points_param;
  compute_cusp_start_end_points(spline_surface,
                                contour_domain_curve_segments,
                                patch_indices,
                                function_start_points,
                                function_end_points,
                                function_start_points_param,
                                function_end_points_param);

  // compute boundary cusps
  compute_boundary_cusps(function_start_points,
                         function_end_points,
                         function_start_points_param,
                         function_end_points_param,
                         closed_contours,
                         boundary_cusps,
                         has_cusp_at_base,
                         has_cusp_at_tip);
}
